using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Corpus;
using Dictionary.Dictionary;
using MorphologicalAnalysis;
using NGram;

namespace SpellChecker
{
    public class TrieBasedSpellChecker : NGramSpellChecker
    {
        private List<string> _generatedWords;
        private Trie _trie;
        
        /// <summary>
        /// A constructor of <see cref="TrieBasedSpellChecker"/> class which takes an <see cref="FsmMorphologicalAnalyzer"/>,
        /// an <see cref="NGram"/> and a <see cref="SpellCheckerParameter"/> as inputs. Then, it calls its super class <see cref="NGramSpellChecker"/> with given inputs.
        /// Finally, it initializes the generatedWords and trie variables.
        /// </summary>
        /// 
        /// <param name="fsm"><see cref="FsmMorphologicalAnalyzer"/> type input.</param>
        /// <param name="nGram"><see cref="NGram"/> type input.</param>
        /// <param name="parameter"><see cref="SpellCheckerParameter"/> type input.</param>
        public TrieBasedSpellChecker(FsmMorphologicalAnalyzer fsm, NGram<string> nGram, SpellCheckerParameter parameter) : base(fsm, nGram, parameter)
        {
            PrepareTrie();
        }
        
        /// <summary>
        /// Another constructor of <see cref="TrieBasedSpellChecker"/> class which takes an <see cref="FsmMorphologicalAnalyzer"/>
        /// and an <see cref="NGram"/> as inputs. Then, it calls its super class <see cref="NGramSpellChecker"/> with given inputs
        /// and initializes the generatedWords and trie variables.
        /// </summary>
        /// 
        /// <param name="fsm"><see cref="FsmMorphologicalAnalyzer"/> type input.</param>
        /// <param name="nGram"><see cref="NGram"/> type input.</param>
        public TrieBasedSpellChecker(FsmMorphologicalAnalyzer fsm, NGram<string> nGram) : base(fsm, nGram)
        {
            PrepareTrie();
        }
        
        /// <summary>
        /// This method overrides the base class method and also loads generated words from a file.
        /// </summary>
        protected override void LoadDictionaries()
        {
            base.LoadDictionaries();
            _generatedWords = new List<string>();
            string line;
            StreamReader trieReader;
            try
            {
                trieReader = GetReader("generated_words.txt");
                line = trieReader.ReadLine();
                while (line != null)
                {
                    _generatedWords.Add(line);
                    line = trieReader.ReadLine();
                }
                trieReader.Close();
            }
            catch (IOException e)
            {
                Console.WriteLine(e.StackTrace);
            }
        }
        
        /// <summary>
        /// Populates a Trie data structure with a set of strings generated by the morphological analyzer.
        /// </summary>
        /// 
        /// <seealso cref="Trie"/>
        /// <seealso cref="FsmMorphologicalAnalyzer.GenerateAllParses(TxtWord, int)"/>
        private void PrepareTrie()
        {
            _trie = new Trie();
            foreach (var word in _generatedWords)
            {
                _trie.Insert(word);
            }
        }
        
        /// <summary>
        /// Checks if the trie object contains the candidate.
        /// If it does, it compares the penalty of the candidate in the results with the penalty of the candidate variable.
        /// If the current penalty of the candidate in the results is less than or equal to the current penalty
        /// of the candidate variable, it removes the first element of the candidates Queue.
        /// If not, it adds the candidate variable to the results List and removes the first element.
        /// If the trie object does not contain the candidate, it checks if the current penalty and the current
        /// index of the candidate variable and if they are not at the limit,
        /// it moves the index one character to the right and generates new candidates.
        /// </summary>
        /// 
        /// <param name="word">The word to search for candidates for.</param>
        /// <param name="sentence">The sentence containing the word.</param>
        /// 
        /// <returns>An ArrayList of Candidate objects representing the potential candidates.</returns>
        protected override List<Candidate> CandidateList(Word word, Sentence sentence)
        {
            TrieCandidate candidate;
            var candidates = new LinkedList<TrieCandidate>();
            var results = new List<TrieCandidate>();
            candidates.AddFirst(new TrieCandidate(word.GetName(), -1, 0));
            string candidateName;
            var penaltyLimit = System.Math.Min(word.CharCount() / 2.0, 3.0);

            while (candidates.Count > 0)
            {
                candidate = candidates.First.Value;
                candidateName = candidate.GetName();
                if (_trie.Search(candidateName))
                {
                    if (results.Contains(candidate) && 
                        results[results.IndexOf(candidate)].GetCurrentPenalty() <= candidate.GetCurrentPenalty())
                    {
                        candidates.RemoveFirst();
                    }
                    else
                    {
                        results.Add(candidate);
                        candidates.RemoveFirst();
                    }
                }
                else
                {
                    if (candidate.GetCurrentPenalty() > penaltyLimit - 1 || candidate.GetCurrentIndex() >= candidateName.Length - 1)
                    {
                        candidates.RemoveFirst();
                    }
                    else
                    {
                        candidates.RemoveFirst();
                        candidate.NextIndex();
                        candidates.AddLast(new TrieCandidate(candidate.GetName(), candidate.GetCurrentIndex(), candidate.GetCurrentPenalty()));
                        var newCandidates = GenerateTrieCandidates(candidate);
                        foreach (var newCandidate in newCandidates)
                        {
                            candidates.AddLast(newCandidate);
                        }
                    }
                }
            }
            return new List<Candidate>(results);
        }
        
        /// <summary>
        /// Generates a set of candidates based on a given TrieCandidate.
        /// The generated candidates are created by applying a set of operations to
        /// the input TrieCandidate. The possible operations are:
        /// De-asciification: replacing certain ASCII characters with their non-ASCII counterparts.
        /// Substitution: replacing a single character with another character.
        /// Insertion: adding a single character to the string.
        /// Deletion: removing a single character from the string.
        /// Transposition: swapping the positions of two adjacent characters in the string.
        /// </summary>
        /// 
        /// <param name="candidate">the input TrieCandidate</param>
        /// 
        /// <returns>a list of candidate strings, each contained in a TrieCandidate object</returns>
        private List<TrieCandidate> GenerateTrieCandidates(TrieCandidate candidate)
        {
            var candidates = new List<TrieCandidate>();
            var currentName = candidate.GetName();
            var currentIndex = candidate.GetCurrentIndex();
            var currentPenalty = candidate.GetCurrentPenalty();
            var deasciified = currentName.ToCharArray();
            string letters;
            var currentNode = _trie.GetTrieNode(currentName.Substring(0,currentIndex));
            
            if (currentNode == null)
            {
                return candidates;
            }
            letters = _trie.GetTrieNode(currentName.Substring(0, currentIndex)).ChildrenToString();
            deasciified[currentIndex] = currentName[currentIndex] switch
            {
                'c' => 'ç',
                'g' => 'ğ',
                'i' => 'ı',
                'o' => 'ö',
                's' => 'ş',
                'u' => 'ü',
                _ => deasciified[currentIndex]
            };
            var deasciifiedWord = new string(deasciified);
            if(!deasciifiedWord.Equals(currentName) && _trie.StartsWith(deasciifiedWord.Substring(0, currentIndex + 1)))
            {
                candidates.Add(new TrieCandidate(deasciifiedWord, currentIndex, currentPenalty + 0.2));
            }

            for (var i = 0; i < letters.Length; i++)
            {
                var replaced = currentName.Substring(0, currentIndex) + letters[i] + currentName.Substring(currentIndex + 1);
                candidates.Add(new TrieCandidate(replaced, currentIndex, currentPenalty + 1));
                
                var added = currentName.Substring(0, currentIndex) + letters[i] + currentName.Substring(currentIndex);
                candidates.Add(new TrieCandidate(added, currentIndex, currentPenalty + 1));
                
                var addedLast = currentName + letters[i];
                if (currentIndex == currentName.Length - 1 && _trie.StartsWith(addedLast))
                {
                    candidates.Add(new TrieCandidate(addedLast, currentIndex, currentPenalty + 1));
                }
            }
            
            var deleted = currentName.Substring(0, currentIndex) + currentName.Substring(currentIndex + 1);
            if (deleted.Length > 1)
            {
                candidates.Add(new TrieCandidate(deleted, currentIndex - 1, currentPenalty + 1));
            }
            
            if (currentIndex < currentName.Length - 1 && currentName[currentIndex] != currentName[currentIndex + 1] && _trie.StartsWith(currentName.Substring(0, currentIndex + 2)))
            {
                var swapped = currentName.Substring(0, currentIndex) + currentName[currentIndex + 1] + currentName[currentIndex] + currentName.Substring(currentIndex + 2);
                candidates.Add(new TrieCandidate(swapped, currentIndex, currentPenalty + 1));
            }
            return candidates;
        }
    }
}